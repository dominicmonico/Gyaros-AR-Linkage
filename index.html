<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GyARos Scanner</title>
  <style>
    body { font-family: system-ui, -apple-system, Arial; margin: 12px; display:flex; flex-direction:column; align-items:center; }
    #reader { width:100%; width:100%; max-width:640px; aspect-ratio:1/1; background:#000; }
    #toast {
      position: fixed; left:50%; transform:translateX(-50%);
      bottom:20px; background:rgba(0,0,0,0.85); color:#fff; padding:10px 14px; border-radius:8px;
      display:none; align-items:center; gap:12px; min-width:260px; justify-content:space-between;
    }
    #toast small { opacity:0.9; display:block; font-size:13px; max-width:420px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    button { padding:8px 10px; font-size:14px; }
    #status { margin:8px 0; color:#333; font-size:14px; }
  </style>
</head>
<body>
  <img src="https://kepea-syrou.kyk.sch.gr/wp-content/uploads/2025/11/GyARos-Logo-black-glow-1.png" style="width:50%;height:auto;"></img>
  <div id="reader"></div>
  <div id="status">Initializing camera…</div>

  <div id="toast" role="status" aria-live="polite">
    <div>
      <div id="toastMsg"><strong>Opening</strong></div>
      <small id="toastUrl"></small>
    </div>
    <div style="display:flex; gap:8px; align-items:center;">
      <div id="countdown" style="font-weight:600">1.0s</div>
    </div>
  </div>

  <script src="https://unpkg.com/html5-qrcode@2.3.8"></script>
  <script>
    // ---- CONFIG: set allowed targets ----
    // Add allowed hostnames or exact URLs. Hostname entries allow any path under that host.
    const REDIRECT_DELAY = 0; // seconds before redirect (short visible cue)
    const REUSE_DEBOUNCE_MS = 1200; // avoid duplicate handling

    // ---- UI refs ----
    const readerId = "reader";
    const readerEl = document.getElementById(readerId);
    const statusEl = document.getElementById('status');
    const toast = document.getElementById('toast');
    const toastMsg = document.getElementById('toastMsg');
    const toastUrl = document.getElementById('toastUrl');
    const countdownEl = document.getElementById('countdown');

    let html5QrCode = null;
    let lastHandled = null;
    let pendingTimer = null;
    let remaining = REDIRECT_DELAY;

    function logStatus(s) { statusEl.textContent = s; }

    function showToastFor(url) {
      toastUrl.textContent = url;
      toastMsg.innerHTML = '<strong>Opening</strong>';
      countdownEl.textContent = remaining.toFixed(1) + 's';
      toast.style.display = 'flex';
    }
    function hideToast() { toast.style.display = 'none'; }

    function clearPending() {
      if (pendingTimer) {
        clearInterval(pendingTimer);
        pendingTimer = null;
      }
    }

    function startCountdownAndRedirect(url) {
      remaining = REDIRECT_DELAY;
      showToastFor(url);
      pendingTimer = setInterval(() => {
        remaining -= 0.1;
        if (remaining <= 0) {
          clearPending();
          hideToast();
          // stop camera then go to location
          if (html5QrCode) {
            html5QrCode.stop().catch(()=>{});
          }
          location.assign(url);
        } else {
          countdownEl.textContent = remaining.toFixed(1) + 's';
        }
      }, 100);
    }

    // Called on each successful scan
    async function onScanSuccess(decodedText) {
      if (!decodedText) return;

      const now = Date.now();
      if (lastHandled && (now - lastHandled.time < REUSE_DEBOUNCE_MS) && lastHandled.text === decodedText) return;
      lastHandled = { text: decodedText, time: now };

      // normalize to a full https URL if needed
      let target = decodedText.trim();
      if (!/^[a-zA-Z][a-zA-Z0-9+.-]*:\/\//.test(target)) target = 'https://' + target;

      logStatus('QR scanned — redirecting…');
      startCountdownAndRedirect(target);
    }

    // Creates the configs based on the size of the reader
    function computeScannerConfig(readerEl, opts = {}) {
    const boxScale = typeof opts.boxScale === 'number' ? opts.boxScale : 0.6;
    const minBox = typeof opts.minBox === 'number' ? opts.minBox : 80;
    const maxBox = typeof opts.maxBox === 'number' ? opts.maxBox : 640;
    const aspectRatio = typeof opts.aspectRatio === 'number' ? opts.aspectRatio : 1.0;

    const minCameraWidth = opts.minCameraWidth || 640;
    const maxCameraWidth = opts.maxCameraWidth || 1920;
    const minCameraHeight = opts.minCameraHeight || 480;
    const maxCameraHeight = opts.maxCameraHeight || 1080;

    // Fallback if readerEl is not provided
    const rect = readerEl && readerEl.getBoundingClientRect ? readerEl.getBoundingClientRect() : {
      width: Math.max(320, Math.floor(window.innerWidth)),
      height: Math.max(240, Math.floor(window.innerHeight))
    };

    const viewportWidth = Math.max(100, Math.floor(rect.width));
    const viewportHeight = Math.max(100, Math.floor(rect.height));
    const dpr = Math.max(1, window.devicePixelRatio || 1);

    // Determine qrbox: scale of the smaller side, clamped to min/max
    const minEdge = Math.min(viewportWidth, viewportHeight);
    let boxEdge = Math.round(minEdge * boxScale);
    boxEdge = Math.max(minBox, Math.min(maxBox, boxEdge));

    // If you want a square qrbox, pass a number. If you want rectangular, pass {width,height}
    const qrbox = boxEdge;

    // Compute ideal camera resolution (use viewport * dpr to request sharper video on high-dpi)
    let idealWidth = Math.round(viewportWidth * dpr);
    let idealHeight = Math.round(viewportHeight * dpr);

    // Respect aspect ratio preference (width / height = aspectRatio)
    if (aspectRatio > 0) {
      // prefer adjusting height to match aspect ratio
      idealHeight = Math.round(idealWidth / aspectRatio);
    }

    // Clamp to safe bounds
    idealWidth = Math.min(maxCameraWidth, Math.max(minCameraWidth, idealWidth));
    idealHeight = Math.min(maxCameraHeight, Math.max(minCameraHeight, idealHeight));

    // Build config for html5-qrcode
    const config = {
      fps: 30,
      qrbox: qrbox,
      aspectRatio: aspectRatio,
      // html5-qrcode accepts videoConstraints for getUserMedia
      videoConstraints: {
        width: { ideal: idealWidth },
        height: { ideal: idealHeight },
        facingMode: "environment"
      },
      // debug info for development
      _debug: { viewportWidth, viewportHeight, dpr, boxEdge, idealWidth, idealHeight }
    };

    return config;
  }

    // Try to start camera on load
    async function createAndStartScanner() {
      const config = computeScannerConfig(readerEl, { boxScale: 0.6, aspectRatio: 1 });
      try {
        if(html5QrCode){
          try{await html5QrCode.stop();}
          catch{}
          try{html5QrCode.clear();}
          catch{}
          html5QrCode = null;
        }
        html5QrCode = new Html5Qrcode(readerId, /* verbose= */ false);
        await html5QrCode.start(
          { facingMode: "environment" },
          config,
          (decodedText) => onScanSuccess(decodedText),
          (err) => {}
        );
        logStatus('Camera started. Point at a QR code.');
      } catch (err) {
        logStatus('Could not start camera: ' + err);
      }
    }

    async function stopAndTidyScanner() {
      if (!html5QrCode) return;
      try{await html5QrCode.stop(); } 
      catch{}
      try{html5QrCode.clear();} 
      catch{}
      html5QrCode = null;
    }

    window.addEventListener('pageshow', (evt) => {
      // evt.persisted is true when restored from bfcache, but we want to start in both cases
      createAndStartScanner();
    });

    window.addEventListener('pagehide', (evt) => {
      // evt.persisted is true when restored from bfcache, but we want to start in both cases
      stopAndTidyScanner();
      clearPending();
      hideToast();
    });
  </script>
</body>
</html>
