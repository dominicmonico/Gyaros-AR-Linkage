<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GyARos Scanner</title>
  <style>
    body { font-family: system-ui, -apple-system, Arial; margin: 12px; display:flex; flex-direction:column; align-items:center; }
    #reader { width:100%; width:100%; max-width:640px; aspect-ratio:1/1; background:#000; }
    #toast {
      position: fixed; left:50%; transform:translateX(-50%);
      bottom:20px; background:rgba(0,0,0,0.85); color:#fff; padding:10px 14px; border-radius:8px;
      display:none; align-items:center; gap:12px; min-width:260px; justify-content:space-between;
    }
    #toast small { opacity:0.9; display:block; font-size:13px; max-width:420px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    button { padding:8px 10px; font-size:14px; }
    #status { margin:8px 0; color:#333; font-size:14px; }
  </style>
</head>
<body>
  <img src="https://kepea-syrou.kyk.sch.gr/wp-content/uploads/2025/11/GyARos-Logo-black-glow-1.png" style="width:50%;height:auto;"></img>
  <div id="reader"></div>
  <div id="status">Initializing camera…</div>

  <div id="toast" role="status" aria-live="polite">
    <div>
      <div id="toastMsg"><strong>Opening</strong></div>
      <small id="toastUrl"></small>
    </div>
    <div style="display:flex; gap:8px; align-items:center;">
      <div id="countdown" style="font-weight:600">1.0s</div>
    </div>
  </div>

  <script src="https://unpkg.com/html5-qrcode@2.3.8"></script>
  <script>
    // ---- CONFIG: set allowed targets ----
    // Add allowed hostnames or exact URLs. Hostname entries allow any path under that host.
    const REDIRECT_DELAY = 0; // seconds before redirect (short visible cue)
    const REUSE_DEBOUNCE_MS = 1200; // avoid duplicate handling

    // ---- UI refs ----
    const readerId = "reader";
    const statusEl = document.getElementById('status');
    const toast = document.getElementById('toast');
    const toastMsg = document.getElementById('toastMsg');
    const toastUrl = document.getElementById('toastUrl');
    const countdownEl = document.getElementById('countdown');

    let html5QrCode = null;
    let lastHandled = null;
    let pendingTimer = null;
    let remaining = REDIRECT_DELAY;

    function logStatus(s) { statusEl.textContent = s; }

    function showToastFor(url) {
      toastUrl.textContent = url;
      toastMsg.innerHTML = '<strong>Opening</strong>';
      countdownEl.textContent = remaining.toFixed(1) + 's';
      toast.style.display = 'flex';
    }
    function hideToast() { toast.style.display = 'none'; }

    function clearPending() {
      if (pendingTimer) {
        clearInterval(pendingTimer);
        pendingTimer = null;
      }
    }

    function startCountdownAndRedirect(url) {
      remaining = REDIRECT_DELAY;
      showToastFor(url);
      pendingTimer = setInterval(() => {
        remaining -= 0.1;
        if (remaining <= 0) {
          clearPending();
          hideToast();
          // stop camera then go to location
          if (html5QrCode) {
            html5QrCode.stop().catch(()=>{});
          }
          location.assign(url);
        } else {
          countdownEl.textContent = remaining.toFixed(1) + 's';
        }
      }, 100);
    }

    // Called on each successful scan
    async function onScanSuccess(decodedText) {
      if (!decodedText) return;

      const now = Date.now();
      if (lastHandled && (now - lastHandled.time < REUSE_DEBOUNCE_MS) && lastHandled.text === decodedText) return;
      lastHandled = { text: decodedText, time: now };

      // normalize to a full https URL if needed
      let target = decodedText.trim();
      if (!/^[a-zA-Z][a-zA-Z0-9+.-]*:\/\//.test(target)) target = 'https://' + target;

      logStatus('QR scanned — redirecting…');
      startCountdownAndRedirect(target);
    }

    // Creates the configs based on the size of the reader
    function computeScannerConfig(readerEl, opts = {}) {
      // Options and safe bounds
      const boxScale = typeof opts.boxScale === 'number' ? opts.boxScale : 0.6; // fraction of smaller side
      const aspectRatio = typeof opts.aspectRatio === 'number' ? opts.aspectRatio : 1.0; // match CSS
      const minCameraWidth = opts.minCameraWidth || 640;
      const maxCameraWidth = opts.maxCameraWidth || 1920;
      const minCameraHeight = opts.minCameraHeight || 480;
      const maxCameraHeight = opts.maxCameraHeight || 1080;

      // Measure viewport (reader element)
      const viewportWidth = Math.max(100, Math.floor(readerEl.clientWidth));
      const viewportHeight = Math.max(100, Math.floor(readerEl.clientHeight));
      const dpr = window.devicePixelRatio || 1;

      // Compute qrbox as a square that fits inside the reader
      const minEdge = Math.min(viewportWidth, viewportHeight);
      const boxEdge = Math.max(80, Math.floor(minEdge * boxScale)); // never smaller than 80px
      const qrbox = boxEdge;

      // Compute ideal camera resolution scaled by devicePixelRatio, clamped to bounds
      let idealWidth = Math.round(viewportWidth * dpr);
      let idealHeight = Math.round(viewportHeight * dpr);

      // Respect aspect ratio preference if provided
      if (aspectRatio && aspectRatio > 0) {
        // adjust idealHeight to match aspectRatio
        idealHeight = Math.round(idealWidth / aspectRatio);
      }

      // Clamp to safe bounds
      idealWidth = Math.min(maxCameraWidth, Math.max(minCameraWidth, idealWidth));
      idealHeight = Math.min(maxCameraHeight, Math.max(minCameraHeight, idealHeight));

      // Build config object for html5-qrcode
      const config = {
        fps: 30,
        qrbox: qrbox,            // object with width/height
        aspectRatio: aspectRatio,
        // Put camera constraints here; html5-qrcode will pass them to getUserMedia
        videoConstraints: {
          width: { ideal: idealWidth },
          height: { ideal: idealHeight },
          facingMode: "environment"
        }
      };

      // Optional debug info
      config._debug = {
        viewportWidth, viewportHeight, dpr, boxEdge, idealWidth, idealHeight
      };

      return config;
    }

    // Try to start camera on load
    async function createAndStartScanner() {
      const config = computeScannerConfig;
      try {
        if(html5QrCode){
          try{await html5QrCode.stop();}
          catch{}
          try{html5QrCode.clear();}
          catch{}
          html5QrCode = null;
        }
        html5QrCode = new Html5Qrcode(readerId, /* verbose= */ false);
        await html5QrCode.start(
          { facingMode: "environment" },
          config,
          (decodedText) => onScanSuccess(decodedText),
          (err) => {}
        );
        logStatus('Camera started. Point at a QR code.');
      } catch (err) {
        logStatus('Could not start camera: ' + err);
      }
    }

    async function stopAndTidyScanner() {
      if (!html5QrCode) return;
      try{await html5QrCode.stop(); } 
      catch{}
      try{html5QrCode.clear();} 
      catch{}
      html5QrCode = null;
    }

    window.addEventListener('pageshow', (evt) => {
      // evt.persisted is true when restored from bfcache, but we want to start in both cases
      createAndStartScanner();
    });

    window.addEventListener('pagehide', (evt) => {
      // evt.persisted is true when restored from bfcache, but we want to start in both cases
      stopAndTidyScanner();
      clearPending();
      hideToast();
    });
  </script>
</body>
</html>
